<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Representative Periods · TimeSeriesClustering.jl</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="TimeSeriesClustering.jl logo"/></a><h1>TimeSeriesClustering.jl</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../quickstart/">Quick Start Guide</a></li><li><a class="toctext" href="../load_data/">Load Data</a></li><li class="current"><a class="toctext" href>Representative Periods</a><ul class="internal"><li><a class="toctext" href="#Clustering-1">Clustering</a></li><li><a class="toctext" href="#Extreme-period-selection-1">Extreme period selection</a></li><li><a class="toctext" href="#ClustResult-struct-1">ClustResult struct</a></li><li><a class="toctext" href="#Example-running-clustering-1">Example running clustering</a></li></ul></li><li><a class="toctext" href="../opt/">Optimization</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Representative Periods</a></li></ul><a class="edit-page" href="https://github.com/holgerteichgraeber/TimeSeriesClustering.jl/blob/master/docs/src/repr_per.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Representative Periods</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Representative-Periods-1" href="#Representative-Periods-1">Representative Periods</a></h1><p>The following describes how to find representative periods out of the full time-series input data. This includes both clustering and extreme period selection.</p><h2><a class="nav-anchor" id="Clustering-1" href="#Clustering-1">Clustering</a></h2><p>The function <code>run_clust()</code> takes the <code>data</code> and gives a <code>ClustResult</code> struct with the clustered data as the output.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeSeriesClustering.run_clust-Tuple{ClustData}" href="#TimeSeriesClustering.run_clust-Tuple{ClustData}"><code>TimeSeriesClustering.run_clust</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">run_clust(data::ClustData;
  norm_op::String=&quot;zscore&quot;,
  norm_scope::String=&quot;full&quot;,
  method::String=&quot;kmeans&quot;,
  representation::String=&quot;centroid&quot;,
  n_clust::Int=5,
  n_seg::Int=data.T,
  n_init::Int=1000,
  iterations::Int=300,
  attribute_weights::Dict{String,Float64}=Dict{String,Float64}(),
  save::String=&quot;&quot;,#QUESTION dead?
  get_all_clust_results::Bool=false,
  kwargs...)</code></pre><p>Take input data <code>data</code> of dimensionality <code>N x T</code> and cluster into data of dimensionality <code>K x T</code>.</p><p>The following combinations of <code>method</code> and <code>representation</code> are supported by <code>run_clust</code>:</p><table><tr><th style="text-align: left">Name</th><th style="text-align: left">method</th><th style="text-align: left">representation</th><th style="text-align: left">comment</th></tr><tr><td style="text-align: left">k-means clustering</td><td style="text-align: left"><code>&lt;kmeans&gt;</code></td><td style="text-align: left"><code>&lt;centroid&gt;</code></td><td style="text-align: left">-</td></tr><tr><td style="text-align: left">k-means clustering with medoid representation</td><td style="text-align: left"><code>&lt;kmeans&gt;</code></td><td style="text-align: left"><code>&lt;medoid&gt;</code></td><td style="text-align: left">-</td></tr><tr><td style="text-align: left">k-medoids clustering (partitional)</td><td style="text-align: left"><code>&lt;kmedoids&gt;</code></td><td style="text-align: left"><code>&lt;medoid&gt;</code></td><td style="text-align: left">-</td></tr><tr><td style="text-align: left">k-medoids clustering (exact)</td><td style="text-align: left"><code>&lt;kmedoids_exact&gt;</code></td><td style="text-align: left"><code>&lt;medoid&gt;</code></td><td style="text-align: left">requires Gurobi and the additional keyword argument <code>kmexact_optimizer</code>. See [examples] folder for example use. Set <code>n_init=1</code></td></tr><tr><td style="text-align: left">hierarchical clustering with centroid representation</td><td style="text-align: left"><code>&lt;hierarchical&gt;</code></td><td style="text-align: left"><code>&lt;centroid&gt;</code></td><td style="text-align: left">set <code>n_init=1</code></td></tr><tr><td style="text-align: left">hierarchical clustering with medoid representation</td><td style="text-align: left"><code>&lt;hierarchical&gt;</code></td><td style="text-align: left"><code>&lt;medoid&gt;</code></td><td style="text-align: left">set <code>n_init=1</code></td></tr></table><p>The other optional inputs are:</p><table><tr><th style="text-align: left">Keyword</th><th style="text-align: left">options</th><th style="text-align: left">comment</th></tr><tr><td style="text-align: left"><code>norm_op</code></td><td style="text-align: left"><code>zscore</code></td><td style="text-align: left">Normalization operation. <code>0-1</code> not yet implemented</td></tr><tr><td style="text-align: left"><code>norm_scope</code></td><td style="text-align: left"><code>full</code>,<code>sequence</code>,<code>hourly</code></td><td style="text-align: left">Normalization scope. The default (<code>full</code>) is used in most of the current literature.</td></tr><tr><td style="text-align: left"><code>n_clust</code></td><td style="text-align: left">e.g. <code>5</code></td><td style="text-align: left">Number of clusters that you want to obtain</td></tr><tr><td style="text-align: left"><code>n_seg</code></td><td style="text-align: left">e.g. <code>10</code></td><td style="text-align: left">Number of segments per period. Not yet implemented, keep as default value.</td></tr><tr><td style="text-align: left"><code>n_init</code></td><td style="text-align: left">e.g. <code>1000</code></td><td style="text-align: left">Number of initializations of locally converging clustering algorithms. <code>10000</code> often yields very stable results.</td></tr><tr><td style="text-align: left"><code>iterations</code></td><td style="text-align: left">e.g. <code>300</code></td><td style="text-align: left">Internal parameter of the partitional clustering algorithms.</td></tr><tr><td style="text-align: left"><code>attribute_weights</code></td><td style="text-align: left">e.g. Dict(&quot;wind-germany&quot;=&gt;3,&quot;solar-germany&quot;=&gt;1,&quot;el_demand-germany&quot;=&gt;5)</td><td style="text-align: left">weights the respective attributes when clustering. In this example, demand and wind are deemed more important than solar.</td></tr><tr><td style="text-align: left"><code>save</code></td><td style="text-align: left"><code>false</code></td><td style="text-align: left">Save clustered data as csv or jld2 file. Not yet implemented.</td></tr><tr><td style="text-align: left"><code>get_all_clust_results</code></td><td style="text-align: left"><code>true</code>,<code>false</code></td><td style="text-align: left"><code>false</code> gives a <code>ClustData</code> struct with only the best locally converged solution in terms of clustering measure. <code>true</code> gives a <code>ClustDataAll</code> struct as output, with all locally converged solutions.</td></tr><tr><td style="text-align: left"><code>kwargs</code></td><td style="text-align: left">e.g. <code>kmexact_optimizer</code></td><td style="text-align: left">optional keyword arguments that are required for specific methods, for example k-medoids exact.</td></tr></table></div></div><a class="source-link" target="_blank" href="https://github.com/holgerteichgraeber/TimeSeriesClustering.jl/blob/371bc9f1db67eba11e14594b471691ce5363bd70/src/clustering/run_clust.jl#L2-L45">source</a></section><p>The following examples show some use cases of <code>run_clust</code>.</p><div></div><pre><code class="language-julia-repl">julia&gt; clust_res = run_clust(ts_input_data) # uses the default values, so this is a k-means clustering algorithm with centroid representation that finds 5 clusters.
ClustResult(ClustData(&quot;none&quot;, [2016], 5, 24, Dict{String,Array}(&quot;solar-germany&quot;=&gt;[0.0 -0.0 … -0.0 -0.0; 0.0 -0.0 … -0.0 -0.0; … ; 0.0 -0.0 … -0.0 -0.0; 0.0 -0.0 … -0.0 -0.0],&quot;wind-germany&quot;=&gt;[0.111879 0.548621 … 0.120139 0.144016; 0.10753 0.551439 … 0.115391 0.140524; … ; 0.117154 0.557464 … 0.130994 0.158663; 0.11598 0.550454 … 0.128324 0.154858],&quot;el_demand-germany&quot;=&gt;[44242.9 46807.9 … 50251.2 42119.1; 44332.4 45903.6 … 49689.1 41490.6; … ; 47708.6 52505.0 … 55596.0 44497.6; 45671.1 49345.3 … 52602.3 42358.4]), [113.0, 28.0, 64.0, 66.0, 95.0], Dict{String,Array}(&quot;solar-germany&quot;=&gt;[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],&quot;wind-germany&quot;=&gt;[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],&quot;el_demand-germany&quot;=&gt;[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]), Dict{String,Array}(&quot;solar-germany&quot;=&gt;[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],&quot;wind-germany&quot;=&gt;[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],&quot;el_demand-germany&quot;=&gt;[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0], [5, 2, 2, 3, 3, 4, 3, 2, 5, 3  …  4, 3, 2, 2, 2, 2, 5, 5, 5, 5]), 5665.825531962603, Dict{String,Any}(&quot;attribute_weights&quot;=&gt;Dict{String,Float64}(),&quot;n_clust&quot;=&gt;5,&quot;method&quot;=&gt;&quot;kmeans&quot;,&quot;iterations&quot;=&gt;300,&quot;norm_op&quot;=&gt;&quot;zscore&quot;,&quot;n_init&quot;=&gt;1000,&quot;norm_scope&quot;=&gt;&quot;full&quot;,&quot;representation&quot;=&gt;&quot;centroid&quot;,&quot;n_seg&quot;=&gt;24))

julia&gt; clust_res = run_clust(ts_input_data;method=&quot;kmedoids&quot;,representation=&quot;medoid&quot;,n_clust=10) #kmedoids clustering that finds 10 clusters
ClustResult(ClustData(&quot;none&quot;, [2016], 10, 24, Dict{String,Array}(&quot;solar-germany&quot;=&gt;[0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0],&quot;wind-germany&quot;=&gt;[0.057912 0.496404 … 0.188496 0.213711; 0.0522746 0.493944 … 0.177836 0.211353; … ; 0.151699 0.449664 … 0.168714 0.227856; 0.145651 0.445769 … 0.164819 0.223858],&quot;el_demand-germany&quot;=&gt;[41520.2 42974.1 … 46793.8 36372.4; 41115.1 41767.7 … 47474.4 36336.5; … ; 40964.4 49259.5 … 50030.8 42491.1; 38478.8 46606.3 … 48053.1 40898.6]), [34.0, 15.0, 99.0, 10.0, 44.0, 36.0, 28.0, 33.0, 37.0, 30.0], Dict{String,Array}(&quot;solar-germany&quot;=&gt;[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],&quot;wind-germany&quot;=&gt;[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],&quot;el_demand-germany&quot;=&gt;[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]), Dict{String,Array}(&quot;solar-germany&quot;=&gt;[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],&quot;wind-germany&quot;=&gt;[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],&quot;el_demand-germany&quot;=&gt;[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0], [6, 2, 2, 7, 7, 9, 7, 7, 6, 2  …  9, 7, 2, 2, 2, 2, 6, 6, 6, 6]), 4411.250669945201, Dict{String,Any}(&quot;attribute_weights&quot;=&gt;Dict{String,Float64}(),&quot;n_clust&quot;=&gt;10,&quot;method&quot;=&gt;&quot;kmedoids&quot;,&quot;iterations&quot;=&gt;300,&quot;norm_op&quot;=&gt;&quot;zscore&quot;,&quot;n_init&quot;=&gt;1000,&quot;norm_scope&quot;=&gt;&quot;full&quot;,&quot;representation&quot;=&gt;&quot;medoid&quot;,&quot;n_seg&quot;=&gt;24))

julia&gt; clust_res = run_clust(ts_input_data;method=&quot;hierarchical&quot;,representation=medoid,n_init=1) # Hierarchical clustering with medoid representation.
ERROR: UndefVarError: medoid not defined</code></pre><p>The resulting struct contains the data, but also cost and configuration information.</p><pre><code class="language-julia-repl">julia&gt; ts_clust_data = clust_res.clust_data
ClustData(&quot;none&quot;, [2016], 10, 24, Dict{String,Array}(&quot;solar-germany&quot;=&gt;[0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0; … ; 0.0 0.0 … 0.0 0.0; 0.0 0.0 … 0.0 0.0],&quot;wind-germany&quot;=&gt;[0.057912 0.496404 … 0.188496 0.213711; 0.0522746 0.493944 … 0.177836 0.211353; … ; 0.151699 0.449664 … 0.168714 0.227856; 0.145651 0.445769 … 0.164819 0.223858],&quot;el_demand-germany&quot;=&gt;[41520.2 42974.1 … 46793.8 36372.4; 41115.1 41767.7 … 47474.4 36336.5; … ; 40964.4 49259.5 … 50030.8 42491.1; 38478.8 46606.3 … 48053.1 40898.6]), [34.0, 15.0, 99.0, 10.0, 44.0, 36.0, 28.0, 33.0, 37.0, 30.0], Dict{String,Array}(&quot;solar-germany&quot;=&gt;[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],&quot;wind-germany&quot;=&gt;[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],&quot;el_demand-germany&quot;=&gt;[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]), Dict{String,Array}(&quot;solar-germany&quot;=&gt;[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],&quot;wind-germany&quot;=&gt;[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],&quot;el_demand-germany&quot;=&gt;[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0], [6, 2, 2, 7, 7, 9, 7, 7, 6, 2  …  9, 7, 2, 2, 2, 2, 6, 6, 6, 6])

julia&gt; clust_cost = clust_res.cost
4411.250669945201

julia&gt; clust_config = clust_res.config
Dict{String,Any} with 9 entries:
  &quot;attribute_weights&quot; =&gt; Dict{String,Float64}()
  &quot;n_clust&quot;           =&gt; 10
  &quot;method&quot;            =&gt; &quot;kmedoids&quot;
  &quot;iterations&quot;        =&gt; 300
  &quot;norm_op&quot;           =&gt; &quot;zscore&quot;
  &quot;n_init&quot;            =&gt; 1000
  &quot;norm_scope&quot;        =&gt; &quot;full&quot;
  &quot;representation&quot;    =&gt; &quot;medoid&quot;
  &quot;n_seg&quot;             =&gt; 24</code></pre><p>The <code>ts_clust_data</code> is a <code>ClustData</code> data struct, this time with clustered data (i.e. less representative periods).</p><p>Shape-based clustering methods are supported in an older version of TimeSeriesClustering: For use of DTW barycenter averaging (DBA) and k-shape clustering on single-attribute data (e.g. electricity prices), please use <a href="https://github.com/holgerteichgraeber/TimeSeriesClustering.jl/tree/v0.1">v0.1</a>.</p><h2><a class="nav-anchor" id="Extreme-period-selection-1" href="#Extreme-period-selection-1">Extreme period selection</a></h2><p>Additionally to clustering the input data, extremes of the data may be relevant to the optimization problem. Therefore, we provide methods for extreme value identification, and to include them in the set of representative periods.</p><p>The methods can be used as follows.</p><pre><code class="language-julia">using TimeSeriesClustering
ts_input_data = load_timeseries_data(:CEP_GER1)
 # define simple extreme days of interest
 ev1 = SimpleExtremeValueDescr(&quot;wind-germany&quot;,&quot;min&quot;,&quot;absolute&quot;)
 ev2 = SimpleExtremeValueDescr(&quot;solar-germany&quot;,&quot;min&quot;,&quot;integral&quot;)
 ev3 = SimpleExtremeValueDescr(&quot;el_demand-germany&quot;,&quot;max&quot;,&quot;absolute&quot;)
 ev = [ev1, ev2, ev3]
 # simple extreme day selection
 ts_input_data_mod,extr_vals,extr_idcs = simple_extr_val_sel(ts_input_data,ev;rep_mod_method=&quot;feasibility&quot;)

 # run clustering
ts_clust_res = run_clust(ts_input_data_mod;method=&quot;kmeans&quot;,representation=&quot;centroid&quot;,n_init=100,n_clust=5) # default k-means

# representation modification
ts_clust_extr = representation_modification(extr_vals,ts_clust_res.clust_data)</code></pre><pre><code class="language-none">ClustData(&quot;none&quot;, [2016], 8, 24, Dict{String,Array}(&quot;solar-germany&quot;=&gt;[-0.0 0.0 … 0.0 0.0; -0.0 0.0 … 0.0 0.0; … ; -0.0 0.0 … 0.0 0.0; -0.0 0.0 … 0.0 0.0],&quot;wind-germany&quot;=&gt;[0.279123 0.111879 … 0.695 0.1098; 0.275462 0.10753 … 0.6591 0.1195; … ; 0.278736 0.117154 … 0.633 0.4397; 0.270642 0.11598 … 0.6394 0.4503],&quot;el_demand-germany&quot;=&gt;[47728.1 44242.9 … 40945.0 55809.0; 47369.8 44332.4 … 39356.0 54536.0; … ; 52237.4 47708.6 … 45446.0 60860.0; 49488.9 45671.1 … 42081.0 57340.0]), [64.0, 113.0, 95.0, 28.0, 66.0, 0.0, 0.0, 0.0], Dict{String,Array}(&quot;solar-germany&quot;=&gt;[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],&quot;wind-germany&quot;=&gt;[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],&quot;el_demand-germany&quot;=&gt;[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0  …  0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0]), Dict{String,Array}(&quot;solar-germany&quot;=&gt;[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],&quot;wind-germany&quot;=&gt;[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0],&quot;el_demand-germany&quot;=&gt;[1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0  …  1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0, 1.0]), [1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0; … ; 1.0 1.0 … 1.0 1.0; 1.0 1.0 … 1.0 1.0], [3, 4, 4, 1, 1, 5, 1, 4, 3, 1  …  5, 1, 4, 4, 4, 4, 3, 3, 3, 3])</code></pre><p>The resulting <code>ts_clust_extr</code> contains both the clustered periods and the extreme periods.</p><p>The extreme periods are first defined by their characteristics by use of <code>SimpleExtremeValueDescr</code>. The struct has the following options:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeSeriesClustering.SimpleExtremeValueDescr-Tuple{String,String,String}" href="#TimeSeriesClustering.SimpleExtremeValueDescr-Tuple{String,String,String}"><code>TimeSeriesClustering.SimpleExtremeValueDescr</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">SimpleExtremeValueDescr(data_type::String,
                             extremum::String,
                             peak_def::String)</code></pre><p>Defines a simple extreme day by its characteristics</p><p>Input options:</p><ul><li>data_type::String : Choose one of the attributes from the data you have loaded into ClustData</li><li>extremum::String : <code>min</code>,<code>max</code></li><li>peak_def::String : <code>absolute</code>,<code>integral</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/holgerteichgraeber/TimeSeriesClustering.jl/blob/371bc9f1db67eba11e14594b471691ce5363bd70/src/utils/datastructs.jl#L147-L158">source</a></section><p>Then, they are selected based on the function <code>simple_extr_val_sel</code>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeSeriesClustering.simple_extr_val_sel-Tuple{ClustData,Array{SimpleExtremeValueDescr,1}}" href="#TimeSeriesClustering.simple_extr_val_sel-Tuple{ClustData,Array{SimpleExtremeValueDescr,1}}"><code>TimeSeriesClustering.simple_extr_val_sel</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">simple_extr_val_sel(data::ClustData,
                    extreme_value_descr_ar::Array{SimpleExtremeValueDescr,1};
                    rep_mod_method::String=&quot;feasibility&quot;)</code></pre><p>Selects simple extreme values and returns modified data, extreme values, and the corresponding indices.</p><p>Inputs options for <code>rep_mod_method</code>:</p><ul><li><code>rep_mod_method</code>::String : <code>feasibility</code>,<code>append</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/holgerteichgraeber/TimeSeriesClustering.jl/blob/371bc9f1db67eba11e14594b471691ce5363bd70/src/clustering/extreme_vals.jl#L1-L10">source</a></section><h2><a class="nav-anchor" id="ClustResult-struct-1" href="#ClustResult-struct-1">ClustResult struct</a></h2><p>The output of <code>run_clust</code> function is a <code>ClustResult</code> struct with the following fields.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeSeriesClustering.ClustResult" href="#TimeSeriesClustering.ClustResult"><code>TimeSeriesClustering.ClustResult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ClustResult &lt;: AbstractClustResult</code></pre><p>Contains the results from a clustering run: The data, the cost in terms of the clustering algorithm, and a config file describing the clustering method used.</p><p>Fields:</p><ul><li>clust_data::ClustData</li><li>cost::Float64: Cost of the clustering algorithm</li><li>config::Dict{String,Any}: Details on the clustering method used</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/holgerteichgraeber/TimeSeriesClustering.jl/blob/371bc9f1db67eba11e14594b471691ce5363bd70/src/utils/datastructs.jl#L74-L82">source</a></section><p>If <code>run_clust</code> is run with the option <code>get_all_clust_results=true</code>, the output is the struct <code>ClustResultAll</code>, which contains all locally converged solutions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="TimeSeriesClustering.ClustResultAll" href="#TimeSeriesClustering.ClustResultAll"><code>TimeSeriesClustering.ClustResultAll</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">ClustResultAll &lt;: AbstractClustResult</code></pre><p>Contains the results from a clustering run for all locally converged solutions</p><p>Fields:</p><ul><li>clust_data::ClustData: The best centers, weights, clustids in terms of cost of the clustering algorithm</li><li>cost::Float64: Cost of the clustering algorithm</li><li>config::Dict{String,Any}: Details on the clustering method used</li><li>centers_all::Array{Array{Float64},1}</li><li>weights_all::Array{Array{Float64},1}</li><li>clustids_all::Array{Array{Int,1},1}</li><li>cost_all::Array{Float64,1}</li><li>iter_all::Array{Int,1}</li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/holgerteichgraeber/TimeSeriesClustering.jl/blob/371bc9f1db67eba11e14594b471691ce5363bd70/src/utils/datastructs.jl#L89-L102">source</a></section><h2><a class="nav-anchor" id="Example-running-clustering-1" href="#Example-running-clustering-1">Example running clustering</a></h2><p>In this example, the wind, solar, and demand data from Germany for 2016 are clustered to 5 representative periods, and the solar data is shown in the plot.</p><pre><code class="language-julia">using TimeSeriesClustering
ts_input_data = load_timeseries_data(:CEP_GER1; T=24, years=[2016])
ts_clust_data = run_clust(ts_input_data;n_clust=5).clust_data
using Plots
plot(ts_clust_data.data[&quot;solar-germany&quot;], legend=false, linestyle=:solid, width=3, xlabel=&quot;Time [h]&quot;, ylabel=&quot;Solar availability factor [%]&quot;)
savefig(&quot;clust.svg&quot;)</code></pre><pre><code class="language-none">┌ Warning: `getindex(df::DataFrame, col_ind::ColumnIndex)` is deprecated, use `df[!, col_ind]` instead.
│   caller = #add_timeseries_data!#12(::Int64, ::Int64, ::Array{Int64,1}, ::Function, ::Dict{String,Array}, ::SubString{String}, ::DataFrames.DataFrame) at load_data.jl:132
└ @ TimeSeriesClustering ~/build/holgerteichgraeber/TimeSeriesClustering.jl/src/utils/load_data.jl:132
/home/travis/.julia/packages/GR/ZI5OE/src/../deps/gr/bin/gksqt: error while loading shared libraries: libQt5Widgets.so.5: cannot open shared object file: No such file or directory
connect: Connection refused
GKS: can&#39;t connect to GKS socket application
Did you start &#39;gksqt&#39;?

GKS: Open failed in routine OPEN_WS
GKS: GKS not in proper state. GKS must be either in the state WSOP or WSAC in routine ACTIVATE_WS</code></pre><p><img src="../clust.svg" alt="Plot"/></p><footer><hr/><a class="previous" href="../load_data/"><span class="direction">Previous</span><span class="title">Load Data</span></a><a class="next" href="../opt/"><span class="direction">Next</span><span class="title">Optimization</span></a></footer></article></body></html>
